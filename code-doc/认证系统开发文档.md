# è®¤è¯ç³»ç»Ÿå¼€å‘æ–‡æ¡£

## é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®å®ç°äº†ä¸€ä¸ªæ”¯æŒå¤šåœ°åŒºéƒ¨ç½²çš„è®¤è¯ç³»ç»Ÿï¼Œèƒ½å¤Ÿæ ¹æ®éƒ¨ç½²åŒºåŸŸè‡ªåŠ¨é€‰æ‹©åˆé€‚çš„è®¤è¯åç«¯ï¼š
- **ä¸­å›½åœ°åŒº**ï¼šä½¿ç”¨è…¾è®¯äº‘ CloudBase + å¾®ä¿¡ç™»å½•
- **å›½é™…åœ°åŒº**ï¼šä½¿ç”¨ Supabase Auth + Google/GitHub OAuth

## ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶

1. **è®¤è¯é€‚é…å™¨å±‚** (`lib/auth/adapter.ts`)
   - ç»Ÿä¸€çš„è®¤è¯æ¥å£æŠ½è±¡
   - æ”¯æŒå¤šç§è®¤è¯æä¾›å•†çš„æ— ç¼åˆ‡æ¢
   - æ ¹æ®éƒ¨ç½²åŒºåŸŸè‡ªåŠ¨é€‰æ‹©è®¤è¯åç«¯

2. **è®¤è¯æœåŠ¡å±‚** (`lib/auth/services/`)
   - `cloudbase-auth.ts`: CloudBase è®¤è¯æœåŠ¡å®ç°
   - `supabase-auth.ts`: Supabase è®¤è¯æœåŠ¡å®ç°

3. **API è·¯ç”±å±‚** (`app/api/auth/`)
   - ç»Ÿä¸€çš„è®¤è¯ API ç«¯ç‚¹
   - æ”¯æŒé‚®ç®±ç™»å½•ã€æ³¨å†Œã€å¾®ä¿¡ç™»å½•ç­‰
   - è‡ªåŠ¨æ ¹æ®åŒºåŸŸé€‰æ‹©è®¤è¯åç«¯

4. **å®¢æˆ·ç«¯å±‚** (`lib/auth/client.ts`)
   - å‰ç«¯ç»Ÿä¸€çš„è®¤è¯å®¢æˆ·ç«¯æ¥å£
   - æä¾›ç±»ä¼¼ Supabase Auth çš„ API ä½“éªŒ

### ç±»å‹ç³»ç»Ÿ

```typescript
// æ ¸å¿ƒç±»å‹å®šä¹‰ (lib/core/types.ts)
export enum DeploymentRegion {
  CN = "CN",      // ä¸­å›½åŒºåŸŸ
  INTL = "INTL"   // å›½é™…åŒºåŸŸ
}

export interface User {
  id: string;
  email?: string;
  name?: string;
  avatar?: string;
  phone?: string;
  createdAt?: Date;
  metadata?: Record<string, any>;
}

export interface AuthResponse {
  user: User | null;
  session?: any;
  error?: Error | null;
}

export interface AuthAdapter {
  signInWithEmail?(email: string, password: string): Promise<AuthResponse>;
  signUpWithEmail?(email: string, password: string): Promise<AuthResponse>;
  signInWithWechat?(code: string): Promise<AuthResponse>;
  signInWithOAuth?(provider: "google" | "github"): Promise<void>;
  signOut(): Promise<void>;
  getCurrentUser(): Promise<User | null>;
  isAuthenticated(): Promise<boolean>;
}
```

## é‚®ç®±ç™»å½•åŠŸèƒ½å®ç°

### 1. ä¸­å›½åŒºåŸŸ - CloudBase å®ç°

#### é€‚é…å™¨å®ç° (lib/auth/adapter.ts)

```typescript
/**
 * CloudBase è®¤è¯é€‚é…å™¨ï¼ˆä¸­å›½ç‰ˆï¼‰
 */
class CloudBaseAuthAdapter implements AuthAdapter {
  async signInWithEmail(email: string, password: string): Promise<AuthResponse> {
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        return {
          user: null,
          error: new Error(errorData.error || "Login failed"),
        };
      }

      const data = await response.json();
      return {
        user: data.user,
        session: data.session,
      };
    } catch (error) {
      return { user: null, error: error as Error };
    }
  }

  async getCurrentUser(): Promise<User | null> {
    // ä» localStorage è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆå®¢æˆ·ç«¯ï¼‰
    if (typeof window !== "undefined") {
      const userJson = localStorage.getItem("auth-user");
      const token = localStorage.getItem("auth-token");

      if (userJson && token) {
        try {
          const user = JSON.parse(userJson);
          return {
            id: user.id || user.userId || "",
            email: user.email,
            name: user.name,
            avatar: user.avatar,
            createdAt: user.createdAt ? new Date(user.createdAt) : undefined,
            metadata: { pro: user.pro, region: user.region },
          };
        } catch (e) {
          console.error("Failed to parse user from localStorage:", e);
        }
      }
    }

    // å°è¯•ä»æœåŠ¡å™¨è·å–ç”¨æˆ·ä¿¡æ¯
    try {
      const response = await fetch("/api/auth/me");
      if (response.ok) {
        const data = await response.json();
        if (data.user) {
          return {
            id: data.user.id || data.user.userId || "",
            email: data.user.email,
            name: data.user.name,
            avatar: data.user.avatar,
            createdAt: data.user.createdAt ? new Date(data.user.createdAt) : undefined,
            metadata: { pro: data.user.pro, region: data.user.region },
          };
        }
      }
    } catch (error) {
      console.error("Failed to fetch current user:", error);
    }

    return null;
  }

  async signOut(): Promise<void> {
    console.log("âœ… ç™»å‡º");
    if (typeof window !== "undefined") {
      localStorage.removeItem("auth-token");
      localStorage.removeItem("auth-user");
      localStorage.removeItem("auth-logged-in");
    }
  }
}
```

#### API æ¥å£å®ç°

```typescript
// pages/api/auth/login.ts (æˆ– app/api/auth/login/route.ts)
import { NextApiRequest, NextApiResponse } from 'next';
import { CloudBase } from '@cloudbase/node-sdk';

const tcb = CloudBase.init({
  env: process.env.WECHAT_CLOUDBASE_ID,
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { email, password } = req.body;

  try {
    // CloudBase é‚®ç®±å¯†ç ç™»å½•
    const auth = tcb.auth();
    const loginResult = await auth.signInWithEmailAndPassword(email, password);

    // è·å–ç”¨æˆ·ä¿¡æ¯
    const userInfo = {
      id: loginResult.uid,
      email: loginResult.email,
      name: loginResult.displayName,
      avatar: loginResult.photoURL,
      createdAt: new Date(loginResult.createdAt),
    };

    // è®¾ç½®è‡ªå®šä¹‰ token
    const customToken = await auth.createCustomToken(loginResult.uid);

    // å­˜å‚¨ç”¨æˆ·ä¼šè¯
    const db = tcb.database();
    await db.collection('users').doc(loginResult.uid).set({
      ...userInfo,
      updatedAt: new Date(),
      lastLoginAt: new Date(),
    });

    res.status(200).json({
      success: true,
      user: userInfo,
      session: {
        access_token: customToken,
        expires_at: Date.now() + 7 * 24 * 60 * 60 * 1000, // 7å¤©
      },
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(401).json({
      success: false,
      error: error.message || 'Login failed',
    });
  }
}
```

### 2. å›½é™…åŒºåŸŸ - Supabase å®ç°

```typescript
/**
 * Supabase è®¤è¯é€‚é…å™¨ï¼ˆå›½é™…ç‰ˆï¼‰
 */
class SupabaseAuthAdapter implements AuthAdapter {
  private supabase: any;

  constructor() {
    // åŠ¨æ€å¯¼å…¥ Supabase å®¢æˆ·ç«¯
    if (typeof window !== 'undefined') {
      import('@supabase/supabase-js').then(({ createClient }) => {
        this.supabase = createClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL || '',
          process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''
        );
      });
    }
  }

  async signInWithEmail(email: string, password: string): Promise<AuthResponse> {
    if (!this.supabase) {
      throw new Error("Supabase å®¢æˆ·ç«¯æœªåˆå§‹åŒ–");
    }

    const { data, error } = await this.supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (error) {
      return { user: null, error };
    }

    return {
      user: {
        id: data.user.id,
        email: data.user.email,
        name: data.user.user_metadata?.name,
        avatar: data.user.user_metadata?.avatar_url,
        createdAt: new Date(data.user.created_at),
        metadata: data.user.user_metadata,
      },
      session: data.session,
    };
  }

  async getCurrentUser(): Promise<User | null> {
    if (!this.supabase) {
      return null;
    }

    const { data: { user } } = await this.supabase.auth.getUser();

    if (!user) {
      return null;
    }

    return {
      id: user.id,
      email: user.email,
      name: user.user_metadata?.name,
      avatar: user.user_metadata?.avatar_url,
      createdAt: new Date(user.created_at),
      metadata: user.user_metadata,
    };
  }

  async signOut(): Promise<void> {
    if (!this.supabase) {
      throw new Error("Supabase å®¢æˆ·ç«¯æœªåˆå§‹åŒ–");
    }

    await this.supabase.auth.signOut();
  }
}
```

## é‚®ç®±æ³¨å†ŒåŠŸèƒ½å®ç°

### 1. ä¸­å›½åŒºåŸŸ - CloudBase æ³¨å†Œ

```typescript
class CloudBaseAuthAdapter implements AuthAdapter {
  async signUpWithEmail(email: string, password: string): Promise<AuthResponse> {
    try {
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          email,
          password,
          confirmPassword: password
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        return {
          user: null,
          error: new Error(errorData.error || "Registration failed"),
        };
      }

      const data = await response.json();
      return {
        user: data.user,
        session: data.session,
      };
    } catch (error) {
      return { user: null, error: error as Error };
    }
  }
}
```

```typescript
// pages/api/auth/register.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { CloudBase } from '@cloudbase/node-sdk';
import bcrypt from 'bcryptjs';

const tcb = CloudBase.init({
  env: process.env.WECHAT_CLOUDBASE_ID,
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { email, password, confirmPassword } = req.body;

  // éªŒè¯è¾“å…¥
  if (!email || !password) {
    return res.status(400).json({ error: 'Email and password are required' });
  }

  if (password !== confirmPassword) {
    return res.status(400).json({ error: 'Passwords do not match' });
  }

  if (password.length < 6) {
    return res.status(400).json({ error: 'Password must be at least 6 characters' });
  }

  try {
    const db = tcb.database();
    const auth = tcb.auth();

    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    const existingUser = await db.collection('users')
      .where({ email })
      .get();

    if (existingUser.data.length > 0) {
      return res.status(409).json({ error: 'Email already registered' });
    }

    // åˆ›å»ºç”¨æˆ·
    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = {
      email,
      password: hashedPassword,
      createdAt: new Date(),
      subscription_plan: 'free',
      pro: false,
      region: 'CN',
    };

    const result = await db.collection('users').add(newUser);

    // åˆ›å»º CloudBase ç”¨æˆ·è®°å½•
    await auth.createUser({
      email,
      password,
      displayName: email.split('@')[0], // é»˜è®¤ç”¨æˆ·å
    });

    // ç”Ÿæˆ token
    const customToken = await auth.createCustomToken(result.id);

    const userInfo = {
      id: result.id,
      email,
      createdAt: newUser.createdAt,
      subscription_plan: newUser.subscription_plan,
      pro: newUser.pro,
      region: newUser.region,
    };

    res.status(201).json({
      success: true,
      user: userInfo,
      session: {
        access_token: customToken,
        expires_at: Date.now() + 7 * 24 * 60 * 60 * 1000,
      },
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'Registration failed',
    });
  }
}
```

### 2. å›½é™…åŒºåŸŸ - Supabase æ³¨å†Œ

```typescript
class SupabaseAuthAdapter implements AuthAdapter {
  async signUpWithEmail(email: string, password: string): Promise<AuthResponse> {
    if (!this.supabase) {
      throw new Error("Supabase å®¢æˆ·ç«¯æœªåˆå§‹åŒ–");
    }

    const { data, error } = await this.supabase.auth.signUp({
      email,
      password,
    });

    if (error) {
      return { user: null, error };
    }

    return {
      user: data.user ? {
        id: data.user.id,
        email: data.user.email,
        name: data.user.user_metadata?.name,
        avatar: data.user.user_metadata?.avatar_url,
        createdAt: new Date(data.user.created_at),
        metadata: data.user.user_metadata,
      } : null,
      session: data.session,
    };
  }
}
```

## å¾®ä¿¡ç™»å½•åŠŸèƒ½å®ç°ï¼ˆä»…ä¸­å›½åŒºåŸŸï¼‰

### 1. å¾®ä¿¡å‰ç«¯ç™»å½•

```typescript
// lib/auth/client.ts
export const auth = {
  signInWithOAuth: async (params: { provider: string; options?: any }) => {
    try {
      const auth = getAuth(getCurrentRegion());

      // å¾®ä¿¡ç™»å½•ä»…æ”¯æŒä¸­å›½åŒºåŸŸ
      if (params.provider === 'wechat' && getCurrentRegion() === DeploymentRegion.CN) {
        // ä½¿ç”¨å¾®ä¿¡ JS-SDK è·å–æˆæƒç 
        const wx = (window as any).wx;
        if (!wx) {
          throw new Error('å¾®ä¿¡ JS-SDK æœªåŠ è½½');
        }

        // è·å–å¾®ä¿¡æˆæƒç 
        const code = await new Promise<string>((resolve, reject) => {
          wx.ready(() => {
            wx.login({
              success: (res: any) => resolve(res.code),
              fail: reject,
            });
          });
        });

        // è°ƒç”¨å¾®ä¿¡ç™»å½•
        const result = await auth.signInWithWechat?.(code);
        return result ? { data: result, error: null } : { data: null, error: new Error('Login failed') };
      }

      return { data: null, error: null };
    } catch (error) {
      return { data: null, error: error as Error };
    }
  },
};
```

### 2. å¾®ä¿¡åç«¯å®ç°

```typescript
class CloudBaseAuthAdapter implements AuthAdapter {
  async signInWithWechat(code: string): Promise<AuthResponse> {
    try {
      const response = await fetch("/api/auth", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "login_wechat", code }),
      });
      const data = await response.json();
      return data.success
        ? { user: data.user }
        : { user: null, error: new Error(data.message) };
    } catch (error) {
      return { user: null, error: error as Error };
    }
  }
}
```

```typescript
// pages/api/auth.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { CloudBase } from '@cloudbase/node-sdk';
import axios from 'axios';

const tcb = CloudBase.init({
  env: process.env.WECHAT_CLOUDBASE_ID,
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { action, code, email, password } = req.body;

  try {
    if (action === 'login_wechat') {
      // é€šè¿‡ code è·å– access_token
      const tokenResponse = await axios.get('https://api.weixin.qq.com/sns/oauth2/access_token', {
        params: {
          appid: process.env.WECHAT_APP_ID,
          secret: process.env.WECHAT_APP_SECRET,
          code,
          grant_type: 'authorization_code',
        },
      });

      const { access_token, openid } = tokenResponse.data;

      if (!access_token || !openid) {
        return res.status(400).json({
          success: false,
          message: 'Failed to get WeChat access token'
        });
      }

      // è·å–ç”¨æˆ·ä¿¡æ¯
      const userInfoResponse = await axios.get('https://api.weixin.qq.com/sns/userinfo', {
        params: {
          access_token,
          openid,
          lang: 'zh_CN',
        },
      });

      const wechatUser = userInfoResponse.data;

      // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
      const db = tcb.database();
      const existingUser = await db.collection('users')
        .where({ wechatOpenId: openid })
        .get();

      let user;
      if (existingUser.data.length > 0) {
        // æ›´æ–°æœ€åç™»å½•æ—¶é—´
        user = existingUser.data[0];
        await db.collection('users').doc(user._id).update({
          lastLoginAt: new Date(),
          wechatUserInfo: wechatUser,
        });
      } else {
        // åˆ›å»ºæ–°ç”¨æˆ·
        const newUser = {
          wechatOpenId: openid,
          name: wechatUser.nickname,
          avatar: wechatUser.headimgurl,
          createdAt: new Date(),
          lastLoginAt: new Date(),
          subscription_plan: 'free',
          pro: false,
          region: 'CN',
          wechatUserInfo,
        };

        const result = await db.collection('users').add(newUser);
        user = { _id: result.id, ...newUser };
      }

      // ç”Ÿæˆè‡ªå®šä¹‰ token
      const auth = tcb.auth();
      const customToken = await auth.createCustomToken(user._id);

      res.status(200).json({
        success: true,
        user: {
          id: user._id,
          name: user.name,
          avatar: user.avatar,
          subscription_plan: user.subscription_plan,
          pro: user.pro,
        },
        session: {
          access_token: customToken,
          expires_at: Date.now() + 7 * 24 * 60 * 60 * 1000,
        },
      });
    }
  } catch (error) {
    console.error('WeChat login error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'WeChat login failed',
    });
  }
}
```

## ç»Ÿä¸€å®¢æˆ·ç«¯æ¥å£

### å®¢æˆ·ç«¯è®¤è¯ç®¡ç†å™¨ (lib/auth/client.ts)

```typescript
/**
 * ç»Ÿä¸€çš„è®¤è¯å®¢æˆ·ç«¯æ¥å£
 */
export interface AuthClient {
  signInWithPassword(params: {
    email: string;
    password: string;
  }): Promise<ClientAuthResponse>;

  signUp(params: { email: string; password: string }): Promise<ClientAuthResponse>;

  signInWithOAuth(params: {
    provider: string;
    options?: any;
  }): Promise<{ data: any; error: Error | null }>;

  signOut(): Promise<{ error: Error | null }>;

  getUser(): Promise<{ data: { user: AuthUser | null }; error: Error | null }>;

  getSession(): Promise<{
    data: { session: AuthSession | null };
    error: Error | null;
  }>;
}

/**
 * ç»Ÿä¸€çš„è®¤è¯å‘½åç©ºé—´å¯¹è±¡
 * æä¾›ç±»ä¼¼ supabase.auth çš„ API
 */
export const auth = {
  // é‚®ç®±å¯†ç ç™»å½•
  signInWithPassword: async (params: { email: string; password: string }) => {
    try {
      const auth = getAuth(getCurrentRegion());
      const result = await auth.signInWithEmail?.(params.email, params.password);
      if (result) {
        return convertAuthResponse(result);
      }
      return { data: { user: null, session: null }, error: new Error('Not supported') };
    } catch (error) {
      return { data: { user: null, session: null }, error: error as Error };
    }
  },

  // é‚®ç®±æ³¨å†Œ
  signUp: async (params: { email: string; password: string }) => {
    try {
      const auth = getAuth(getCurrentRegion());
      const result = await auth.signUpWithEmail?.(params.email, params.password);
      if (result) {
        return convertAuthResponse(result);
      }
      return { data: { user: null, session: null }, error: new Error('Not supported') };
    } catch (error) {
      return { data: { user: null, session: null }, error: error as Error };
    }
  },

  // OAuth ç™»å½•ï¼ˆåŒ…æ‹¬å¾®ä¿¡ï¼‰
  signInWithOAuth: async (params: { provider: string; options?: any }) => {
    try {
      const auth = getAuth(getCurrentRegion());

      if (params.provider === 'wechat' && getCurrentRegion() === DeploymentRegion.CN) {
        await auth.signInWithWechat?.('');
        return { data: null, error: null };
      } else {
        await auth.signInWithOAuth?.(params.provider as "google" | "github");
        return { data: null, error: null };
      }
    } catch (error) {
      return { data: null, error: error as Error };
    }
  },

  // ç™»å‡º
  signOut: async () => {
    try {
      const auth = getAuth(getCurrentRegion());
      await auth.signOut();
      return { error: null };
    } catch (error) {
      return { error: error as Error };
    }
  },

  // è·å–å½“å‰ç”¨æˆ·
  getUser: async () => {
    try {
      const auth = getAuth(getCurrentRegion());
      const user = await auth.getCurrentUser();
      if (user) {
        return {
          data: {
            user: {
              id: user.id,
              email: user.email,
              user_metadata: user.metadata || {},
            },
          },
          error: null,
        };
      }
      return { data: { user: null }, error: null };
    } catch (error) {
      return { data: { user: null }, error: error as Error };
    }
  },
};
```

## é€‚é…å™¨å·¥å‚å’Œé…ç½®

### é€‚é…å™¨å·¥å‚ (lib/auth/adapter.ts)

```typescript
/**
 * åˆ›å»ºè®¤è¯é€‚é…å™¨
 */
export function createAuthAdapter(region: DeploymentRegion): AuthAdapter {
  if (region === DeploymentRegion.CN) {
    console.log("ğŸ” ä½¿ç”¨ CloudBase è®¤è¯ï¼ˆä¸­å›½ç‰ˆï¼‰");
    return new CloudBaseAuthAdapter();
  } else {
    console.log("ğŸ” ä½¿ç”¨ Supabase è®¤è¯ï¼ˆå›½é™…ç‰ˆï¼‰");
    return new SupabaseAuthAdapter();
  }
}

/**
 * è·å–è®¤è¯å®ä¾‹ï¼ˆå¸¦åŒºåŸŸè‡ªåŠ¨æ£€æµ‹ï¼‰
 */
export function getAuth(region?: DeploymentRegion): AuthAdapter {
  const targetRegion = region || (isChinaRegion() ? DeploymentRegion.CN : DeploymentRegion.INTL);

  if (!authInstance) {
    authInstance = createAuthAdapter(targetRegion);
  }
  return authInstance;
}

/**
 * æ£€æŸ¥å½“å‰åŒºåŸŸæ˜¯å¦æ”¯æŒæŸä¸ªè®¤è¯åŠŸèƒ½
 */
export function isAuthFeatureSupported(
  feature: string,
  region: DeploymentRegion
): boolean {
  const features = {
    [DeploymentRegion.CN]: {
      emailAuth: true,
      wechatAuth: true,
      googleAuth: false,
      githubAuth: false,
    },
    [DeploymentRegion.INTL]: {
      emailAuth: true,
      wechatAuth: false,
      googleAuth: true,
      githubAuth: true,
    },
  };

  return features[region]?.[feature as keyof typeof features[typeof region]] || false;
}
```

## éƒ¨ç½²é…ç½®

### ç¯å¢ƒå˜é‡é…ç½®

```bash
# ä¸­å›½åŒºåŸŸé…ç½®
NEXT_PUBLIC_DEPLOYMENT_REGION=CN
WECHAT_CLOUDBASE_ID=your-cloudbase-env-id
WECHAT_APP_ID=your-wechat-app-id
WECHAT_APP_SECRET=your-wechat-app-secret

# å›½é™…åŒºåŸŸé…ç½®
NEXT_PUBLIC_DEPLOYMENT_REGION=INTL
NEXT_PUBLIC_SUPABASE_URL=your-supabase-project-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
SUPABASE_URL=your-supabase-project-url
SUPABASE_ANON_KEY=your-supabase-anon-key

# æ”¯ä»˜é…ç½®ï¼ˆå¯é€‰ï¼‰
STRIPE_SECRET_KEY=sk_test_...
STRIPE_PUBLIC_KEY=pk_test_...
PAYPAL_CLIENT_ID=your-paypal-client-id
```

### é…ç½®ç®¡ç† (lib/config/deployment.ts)

```typescript
/**
 * æ ¹æ®éƒ¨ç½²åŒºåŸŸç”Ÿæˆé…ç½®
 */
function generateConfig(region: DeploymentRegion): DeploymentConfig {
  const isChinaRegion = region === DeploymentRegion.CN;

  return {
    region,
    appName: "Multi-Region Platform",
    version: "1.0.0",

    auth: {
      provider: isChinaRegion ? "cloudbase" : "supabase",
      features: {
        emailAuth: true, // å…¨åœ°åŒºæ”¯æŒ
        wechatAuth: isChinaRegion, // ä»…ä¸­å›½æ”¯æŒ
        googleAuth: !isChinaRegion, // ä»…å›½é™…æ”¯æŒ
        githubAuth: !isChinaRegion, // ä»…å›½é™…æ”¯æŒ
      },
    },

    database: {
      provider: isChinaRegion ? "cloudbase" : "supabase",
    },

    payment: {
      providers: isChinaRegion ? ["wechat", "alipay"] : ["stripe", "paypal"],
    },

    apis: {
      authCallbackPath: "/auth/callback",
    },

    logging: {
      level: process.env.NODE_ENV === "production" ? "info" : "debug",
      enableConsole: process.env.NODE_ENV !== "production",
    },
  };
}
```

## å‰ç«¯ä½¿ç”¨ç¤ºä¾‹

### React Hook å®ç°

```typescript
// hooks/use-auth.tsx
import { useState, useEffect } from 'react';
import { auth } from '../lib/auth/client';
import { AuthUser, AuthSession } from '../lib/auth/client';

export function useAuth() {
  const [user, setUser] = useState<AuthUser | null>(null);
  const [session, setSession] = useState<AuthSession | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const initAuth = async () => {
      try {
        const { data: { session } } = await auth.getSession();
        const { data: { user } } = await auth.getUser();

        setSession(session);
        setUser(user);
      } catch (error) {
        console.error('Auth initialization error:', error);
      } finally {
        setLoading(false);
      }
    };

    initAuth();
  }, []);

  const signIn = async (email: string, password: string) => {
    setLoading(true);
    try {
      const result = await auth.signInWithPassword({ email, password });
      if (result.data.user && result.data.session) {
        setUser(result.data.user);
        setSession(result.data.session);
      }
      return result;
    } catch (error) {
      console.error('Sign in error:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const signUp = async (email: string, password: string) => {
    setLoading(true);
    try {
      const result = await auth.signUp({ email, password });
      if (result.data.user && result.data.session) {
        setUser(result.data.user);
        setSession(result.data.session);
      }
      return result;
    } catch (error) {
      console.error('Sign up error:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const signInWithWechat = async () => {
    setLoading(true);
    try {
      const result = await auth.signInWithOAuth({ provider: 'wechat' });
      if (result.error) {
        throw result.error;
      }
      return result;
    } catch (error) {
      console.error('WeChat sign in error:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const signOut = async () => {
    setLoading(true);
    try {
      await auth.signOut();
      setUser(null);
      setSession(null);
    } catch (error) {
      console.error('Sign out error:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  };

  return {
    user,
    session,
    loading,
    signIn,
    signUp,
    signInWithWechat,
    signOut,
  };
}
```

### ç™»å½•ç»„ä»¶ç¤ºä¾‹

```typescript
// components/LoginForm.tsx
import React, { useState } from 'react';
import { useAuth } from '../hooks/use-auth';

export function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isSignUp, setIsSignUp] = useState(false);
  const { signIn, signUp, signInWithWechat, loading } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      if (isSignUp) {
        await signUp(email, password);
      } else {
        await signIn(email, password);
      }
    } catch (error) {
      console.error('Auth error:', error);
      // å¤„ç†é”™è¯¯æ˜¾ç¤º
    }
  };

  const handleWechatLogin = async () => {
    try {
      await signInWithWechat();
    } catch (error) {
      console.error('WeChat login error:', error);
      // å¤„ç†é”™è¯¯æ˜¾ç¤º
    }
  };

  return (
    <div className="auth-form">
      <h2>{isSignUp ? 'æ³¨å†Œ' : 'ç™»å½•'}</h2>

      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label htmlFor="email">é‚®ç®±</label>
          <input
            type="email"
            id="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>

        <div className="form-group">
          <label htmlFor="password">å¯†ç </label>
          <input
            type="password"
            id="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>

        <button type="submit" disabled={loading}>
          {loading ? 'å¤„ç†ä¸­...' : (isSignUp ? 'æ³¨å†Œ' : 'ç™»å½•')}
        </button>
      </form>

      {/* å¾®ä¿¡ç™»å½• - ä»…ä¸­å›½åŒºåŸŸæ˜¾ç¤º */}
      {process.env.NEXT_PUBLIC_DEPLOYMENT_REGION === 'CN' && (
        <div className="wechat-login">
          <button
            type="button"
            onClick={handleWechatLogin}
            disabled={loading}
          >
            å¾®ä¿¡ç™»å½•
          </button>
        </div>
      )}

      <div className="auth-toggle">
        <button
          type="button"
          onClick={() => setIsSignUp(!isSignUp)}
        >
          {isSignUp ? 'å·²æœ‰è´¦å·ï¼Ÿç™»å½•' : 'æ²¡æœ‰è´¦å·ï¼Ÿæ³¨å†Œ'}
        </button>
      </div>
    </div>
  );
}
```

## é”™è¯¯å¤„ç†å’Œæœ€ä½³å®è·µ

### é”™è¯¯ç±»å‹å®šä¹‰

```typescript
// lib/auth/errors.ts
export class AuthError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 400
  ) {
    super(message);
    this.name = 'AuthError';
  }
}

export const AuthErrors = {
  INVALID_CREDENTIALS: new AuthError('é‚®ç®±æˆ–å¯†ç é”™è¯¯', 'INVALID_CREDENTIALS', 401),
  EMAIL_ALREADY_EXISTS: new AuthError('é‚®ç®±å·²è¢«æ³¨å†Œ', 'EMAIL_ALREADY_EXISTS', 409),
  WECHAT_LOGIN_FAILED: new AuthError('å¾®ä¿¡ç™»å½•å¤±è´¥', 'WECHAT_LOGIN_FAILED', 400),
  USER_NOT_FOUND: new AuthError('ç”¨æˆ·ä¸å­˜åœ¨', 'USER_NOT_FOUND', 404),
  TOKEN_EXPIRED: new AuthError('ç™»å½•å·²è¿‡æœŸ', 'TOKEN_EXPIRED', 401),
  NETWORK_ERROR: new AuthError('ç½‘ç»œè¿æ¥å¤±è´¥', 'NETWORK_ERROR', 500),
};
```

### å®‰å…¨æœ€ä½³å®è·µ

1. **å¯†ç å®‰å…¨**
   ```typescript
   import bcrypt from 'bcryptjs';

   const hashedPassword = await bcrypt.hash(password, 12);
   const isValid = await bcrypt.compare(password, hashedPassword);
   ```

2. **JWT Token ç®¡ç†**
   ```typescript
   import jwt from 'jsonwebtoken';

   const token = jwt.sign(
     { userId: user.id, email: user.email },
     process.env.JWT_SECRET!,
     { expiresIn: '7d' }
   );
   ```

3. **ç¯å¢ƒå˜é‡å®‰å…¨**
   ```typescript
   // ç”Ÿäº§ç¯å¢ƒéªŒè¯
   if (process.env.NODE_ENV === 'production') {
     const required = ['WECHAT_APP_SECRET', 'SUPABASE_URL'];
     const missing = required.filter(key => !process.env[key]);
     if (missing.length > 0) {
       throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
     }
   }
   ```

## æµ‹è¯•æŒ‡å—

### å•å…ƒæµ‹è¯•ç¤ºä¾‹

```typescript
// __tests__/auth.test.ts
import { CloudBaseAuthAdapter, SupabaseAuthAdapter } from '../lib/auth/adapter';

describe('Auth Adapter', () => {
  describe('CloudBase Adapter', () => {
    let adapter: CloudBaseAuthAdapter;

    beforeEach(() => {
      adapter = new CloudBaseAuthAdapter();
    });

    test('should sign in with email and password', async () => {
      // Mock fetch response
      global.fetch = jest.fn().mockResolvedValue({
        ok: true,
        json: async () => ({
          success: true,
          user: { id: 'test-id', email: 'test@example.com' },
        }),
      });

      const result = await adapter.signInWithEmail('test@example.com', 'password');

      expect(result.user).toBeTruthy();
      expect(result.user?.email).toBe('test@example.com');
      expect(result.error).toBeNull();
    });
  });
});
```

## éƒ¨ç½²è¯´æ˜

### ä¸­å›½åŒºåŸŸéƒ¨ç½²

1. **è…¾è®¯äº‘ CloudBase é…ç½®**
   - åˆ›å»º CloudBase ç¯å¢ƒ
   - å¯ç”¨è®¤è¯æœåŠ¡
   - é…ç½®å¾®ä¿¡ç™»å½•

2. **å¾®ä¿¡å…¬ä¼—å¹³å°é…ç½®**
   - ç”³è¯·å¾®ä¿¡å…¬ä¼—å¹³å°è´¦å·
   - é…ç½®ç½‘é¡µæˆæƒåŸŸå
   - è·å– AppID å’Œ AppSecret

### å›½é™…åŒºåŸŸéƒ¨ç½²

1. **Supabase é¡¹ç›®é…ç½®**
   - åˆ›å»º Supabase é¡¹ç›®
   - é…ç½®è®¤è¯æä¾›å•†
   - è®¾ç½® OAuth é‡å®šå‘ URL

2. **ç¯å¢ƒå˜é‡é…ç½®**
   - Supabase URL å’Œå¯†é’¥
   - OAuth æä¾›å•†é…ç½®

## æ€»ç»“

æœ¬è®¤è¯ç³»ç»Ÿé€šè¿‡é€‚é…å™¨æ¨¡å¼å®ç°äº†å¤šåœ°åŒºæ”¯æŒçš„ç»Ÿä¸€æ¥å£ï¼Œæ”¯æŒé‚®ç®±ç™»å½•ã€æ³¨å†Œå’Œå¾®ä¿¡ç™»å½•åŠŸèƒ½ã€‚ç³»ç»Ÿå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **å¤šåœ°åŒºæ”¯æŒ**: æ ¹æ®éƒ¨ç½²åŒºåŸŸè‡ªåŠ¨é€‰æ‹©åˆé€‚çš„è®¤è¯æä¾›å•†
2. **ç»Ÿä¸€æ¥å£**: å‰ç«¯ä»£ç æ— éœ€å…³å¿ƒåç«¯å®ç°å·®å¼‚
3. **ç±»å‹å®‰å…¨**: å®Œæ•´çš„ TypeScript ç±»å‹å®šä¹‰
4. **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶
5. **æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°çš„è®¤è¯æä¾›å•†

ç³»ç»Ÿå¯ä»¥æ ¹æ® `NEXT_PUBLIC_DEPLOYMENT_REGION` ç¯å¢ƒå˜é‡è‡ªåŠ¨åˆ‡æ¢è®¤è¯æ¨¡å¼ï¼Œä¸ºä¸åŒåœ°åŒºçš„ç”¨æˆ·æä¾›æœ€ä½³ä½“éªŒã€‚